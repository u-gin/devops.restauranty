name: Deploy to EKS

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  # Common env you may use across jobs
  AWS_REGION: ${{ secrets.AWS_REGION }}
  EKS_CLUSTER_NAME: ${{ secrets.EKS_CLUSTER_NAME }}
  K8S_NAMESPACE: ${{ secrets.K8S_NAMESPACE }}
  DOCKER_ORG: ${{ secrets.DOCKER_ORG }}
  INGRESS_HOST: ${{ secrets.INGRESS_HOST }}

jobs:
  build-and-push:
    name: Build and push
    runs-on: ubuntu-latest

    strategy:
      matrix:
        app: [auth, discounts, items, client]

    permissions:
      id-token: write
      contents: read

    steps:
        
      # Checkout Code
      - name: Checkout repository
        uses: actions/checkout@v4

      # Configure AWS 
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # Docker Hub
      - name: Login to docker hub using username and token\
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Set up buildx for arm architecture
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Assign tag using SHA
      - name: Define image meta
        id: meta
        run: |
          SHA_TAG=${GITHUB_SHA::7}
          echo "sha_tag=$SHA_TAG" >> $GITHUB_OUTPUT

          case "${{ matrix.app }}" in
          auth)
            echo "image=${{ secrets.DOCKER_USERNAME }}/auth" >> $GITHUB_OUTPUT
            echo "context=./backend/auth" >> $GITHUB_OUTPUT
            ;;
          
          discounts)
            echo "image=${{ secrets.DOCKER_USERNAME }}/discounts" >> $GITHUB_OUTPUT
            echo "context=./backend/discounts" >> $GITHUB_OUTPUT
            ;;

          items)
            echo "image=${{ secrets.DOCKER_USERNAME }}/items" >> $GITHUB_OUTPUT
            echo "context=./backend/items" >> $GITHUB_OUTPUT
            ;;

          client)
            echo "image=${{ secrets.DOCKER_USERNAME }}/client" >> $GITHUB_OUTPUT
            echo "context=./client" >> $GITHUB_OUTPUT
            ;;
          esac
    
      #Build and push images
      - name: Build and push images to docker hub
        uses: docker/build-push-action@v6
        with:
          context: ${{ steps.meta.outputs.context }}
          file: ${{ steps.meta.outputs.context }}/Dockerfile
          push: true
          tags: |
            ${{ steps.meta.outputs.image }}:${{ steps.meta.outputs.sha_tag }}
            ${{ steps.meta.outputs.image }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max


  deploy:
    name: Deploy to EKS
    runs-on: ubuntu-latest
    needs: [ build-and-push ]
    permissions:
        contents: read

    steps:
        # Get repo code
      - name: Checkout
        uses: actions/checkout@v4

        # Authenticate to AWS
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
            aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
            aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
            aws-region:            ${{ secrets.AWS_REGION }}

        # Connect kubectl to cluster
      - name: Update kubeconfig for EKS
        run: |
            aws eks update-kubeconfig --region "$AWS_REGION" --name "$EKS_CLUSTER_NAME"

        # Sanity checks
      - name: Verify access
        run: |
            kubectl version
            kubectl get ns
            kubectl get ingress -A || true

        # Ensure namespace exists
      - name: Create namespace if missing
        run: |
            kubectl get ns "$K8S_NAMESPACE" || kubectl create ns "$K8S_NAMESPACE"

      # Apply all Kubernetes resources in /k8s
      - name: Apply base k8s
        run: |
            kubectl apply -n "$K8S_NAMESPACE" -f k8s/

      # Compute image tags for all services
      - name: Compute image tags
        id: tag
        run: |
            SHA_TAG=${GITHUB_SHA::7}

            # Images for postgres and redis
            # echo "redis_image=redis:latest" >> $GITHUB_OUTPUT
            echo "mongo_image=mongo:8" >> $GITHUB_OUTPUT

            # Images with SHA tag
            echo "auth_image=${{ secrets.DOCKER_USERNAME }}/auth:${SHA_TAG}" >> $GITHUB_OUTPUT
            echo "discounts_image=${{ secrets.DOCKER_USERNAME }}/discounts:${SHA_TAG}" >> $GITHUB_OUTPUT
            echo "items_image=${{ secrets.DOCKER_USERNAME }}/items:${SHA_TAG}" >> $GITHUB_OUTPUT
            echo "client_image=${{ secrets.DOCKER_USERNAME }}/client:${SHA_TAG}" >> $GITHUB_OUTPUT

      # Update deployment with the new image
      - name: Set images to new SHA tag
        run: |
            kubectl -n "$K8S_NAMESPACE" set image deployment/eugene-deployment-auth auth=${{ steps.tag.outputs.auth_image }}
            kubectl -n "$K8S_NAMESPACE" set image deployment/eugene-deployment-discounts discounts=${{ steps.tag.outputs.discounts_image }}
            kubectl -n "$K8S_NAMESPACE" set image deployment/eugene-deployment-items items=${{ steps.tag.outputs.items_image }}
            kubectl -n "$K8S_NAMESPACE" set image deployment/eugene-deployment-client client=${{ steps.tag.outputs.client_image }}

        # Wait for all app rollouts
      - name: Wait for rollout (mongo)
        run: kubectl -n "$K8S_NAMESPACE" rollout status deploy/eugene-mongo --timeout=120s

      - name: Wait for rollout (auth)
        run: kubectl -n "$K8S_NAMESPACE" rollout status deploy/eugene-deployment-auth --timeout=120s

      - name: Wait for rollout (discounts)
        run: kubectl -n "$K8S_NAMESPACE" rollout status deploy/eugene-deployment-discounts --timeout=120s

      - name: Wait for rollout (items)
        run: kubectl -n "$K8S_NAMESPACE" rollout status deploy/eugene-deployment-items --timeout=120s

      - name: Wait for rollout (client)
        run: kubectl -n "$K8S_NAMESPACE" rollout status deploy/eugene-deployment-client --timeout=120s
